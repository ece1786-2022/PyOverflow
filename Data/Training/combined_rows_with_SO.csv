content,topic,label
"In Python, all exceptions must be instances of a class that derives from BaseException.  In a try statement with an except clause that mentions a particular class, that clause also handles any exception classes derived from that class (but not exception classes from which it is derived).  Two exception classes that are not related via subclassing are never equivalent, even if they have the same name",Built-in Exceptions,0
"  In a try statement with an except clause that mentions a particular class, that clause also handles any exception classes derived from that class (but not exception classes from which it is derived).  Two exception classes that are not related via subclassing are never equivalent, even if they have the same name. The built-in exceptions listed below can be generated by the interpreter or built-in functions",Built-in Exceptions,0
"  Two exception classes that are not related via subclassing are never equivalent, even if they have the same name. The built-in exceptions listed below can be generated by the interpreter or built-in functions.  Except where mentioned, they have an “associated value” indicating the detailed cause of the error",Built-in Exceptions,0
" The built-in exceptions listed below can be generated by the interpreter or built-in functions.  Except where mentioned, they have an “associated value” indicating the detailed cause of the error.  This may be a string or a tuple of several items of information (e",Built-in Exceptions,0
"  Except where mentioned, they have an “associated value” indicating the detailed cause of the error.  This may be a string or a tuple of several items of information (e.g",Built-in Exceptions,0
"  This may be a string or a tuple of several items of information (e.g., an error code and a string explaining the code)",Built-in Exceptions,0
"g., an error code and a string explaining the code).  The associated value is usually passed as arguments to the exception class’s constructor",Built-in Exceptions,0
", an error code and a string explaining the code).  The associated value is usually passed as arguments to the exception class’s constructor. User code can raise built-in exceptions",Built-in Exceptions,0
  The associated value is usually passed as arguments to the exception class’s constructor. User code can raise built-in exceptions.  This can be used to test an exception handler or to report an error condition “just like” the situation in which the interpreter raises the same exception; but beware that there is nothing to prevent user code from raising an inappropriate error,Built-in Exceptions,0
" User code can raise built-in exceptions.  This can be used to test an exception handler or to report an error condition “just like” the situation in which the interpreter raises the same exception; but beware that there is nothing to prevent user code from raising an inappropriate error. The built-in exception classes can be subclassed to define new exceptions; programmers are encouraged to derive new exceptions from the Exception class or one of its subclasses, and not from BaseException",Built-in Exceptions,0
"  This can be used to test an exception handler or to report an error condition “just like” the situation in which the interpreter raises the same exception; but beware that there is nothing to prevent user code from raising an inappropriate error. The built-in exception classes can be subclassed to define new exceptions; programmers are encouraged to derive new exceptions from the Exception class or one of its subclasses, and not from BaseException.  More information on defining exceptions is available in the Python Tutorial under User-defined Exceptions",Built-in Exceptions,0
" The built-in exception classes can be subclassed to define new exceptions; programmers are encouraged to derive new exceptions from the Exception class or one of its subclasses, and not from BaseException.  More information on defining exceptions is available in the Python Tutorial under User-defined Exceptions. When raising a new exception while another exception is already being handled, the new exception’s __context__ attribute is automatically set to the handled exception",Built-in Exceptions,0
"  More information on defining exceptions is available in the Python Tutorial under User-defined Exceptions. When raising a new exception while another exception is already being handled, the new exception’s __context__ attribute is automatically set to the handled exception.  An exception may be handled when an except or finally clause, or a with statement, is used",Built-in Exceptions,0
" When raising a new exception while another exception is already being handled, the new exception’s __context__ attribute is automatically set to the handled exception.  An exception may be handled when an except or finally clause, or a with statement, is used. This implicit exception context can be supplemented with an explicit cause by using from with raise: The expression following from must be an exception or None",Built-in Exceptions,0
"  An exception may be handled when an except or finally clause, or a with statement, is used. This implicit exception context can be supplemented with an explicit cause by using from with raise: The expression following from must be an exception or None. It will be set as __cause__ on the raised exception",Built-in Exceptions,0
" This implicit exception context can be supplemented with an explicit cause by using from with raise: The expression following from must be an exception or None. It will be set as __cause__ on the raised exception. Setting __cause__ also implicitly sets the __suppress_context__ attribute to True, so that using raise new_exc from None effectively replaces the old exception with the new one for display purposes (e",Built-in Exceptions,0
" It will be set as __cause__ on the raised exception. Setting __cause__ also implicitly sets the __suppress_context__ attribute to True, so that using raise new_exc from None effectively replaces the old exception with the new one for display purposes (e.g",Built-in Exceptions,0
" Setting __cause__ also implicitly sets the __suppress_context__ attribute to True, so that using raise new_exc from None effectively replaces the old exception with the new one for display purposes (e.g. converting KeyError to AttributeError), while leaving the old exception available in __context__ for introspection when debugging",Built-in Exceptions,0
"g. converting KeyError to AttributeError), while leaving the old exception available in __context__ for introspection when debugging. The default traceback display code shows these chained exceptions in addition to the traceback for the exception itself",Built-in Exceptions,0
" converting KeyError to AttributeError), while leaving the old exception available in __context__ for introspection when debugging. The default traceback display code shows these chained exceptions in addition to the traceback for the exception itself. An explicitly chained exception in __cause__ is always shown when present",Built-in Exceptions,0
 The default traceback display code shows these chained exceptions in addition to the traceback for the exception itself. An explicitly chained exception in __cause__ is always shown when present. An implicitly chained exception in __context__ is shown only if __cause__ is None and __suppress_context__ is false,Built-in Exceptions,0
" An explicitly chained exception in __cause__ is always shown when present. An implicitly chained exception in __context__ is shown only if __cause__ is None and __suppress_context__ is false. In either case, the exception itself is always shown after any chained exceptions so that the final line of the traceback always shows the last exception that was raised",Built-in Exceptions,0
" An implicitly chained exception in __context__ is shown only if __cause__ is None and __suppress_context__ is false. In either case, the exception itself is always shown after any chained exceptions so that the final line of the traceback always shows the last exception that was raised. User code can create subclasses that inherit from an exception type",Built-in Exceptions,0
" In either case, the exception itself is always shown after any chained exceptions so that the final line of the traceback always shows the last exception that was raised. User code can create subclasses that inherit from an exception type. It’s recommended to only subclass one exception type at a time to avoid any possible conflicts between how the bases handle the args attribute, as well as due to possible memory layout incompatibilities",Built-in Exceptions,0
" User code can create subclasses that inherit from an exception type. It’s recommended to only subclass one exception type at a time to avoid any possible conflicts between how the bases handle the args attribute, as well as due to possible memory layout incompatibilities. The following exceptions are used mostly as base classes for other exceptions",Built-in Exceptions,0
" It’s recommended to only subclass one exception type at a time to avoid any possible conflicts between how the bases handle the args attribute, as well as due to possible memory layout incompatibilities. The following exceptions are used mostly as base classes for other exceptions. The following exceptions are the exceptions that are usually raised",Built-in Exceptions,0
 The following exceptions are used mostly as base classes for other exceptions. The following exceptions are the exceptions that are usually raised. The following exceptions are kept for compatibility with previous versions; starting from Python 3,Built-in Exceptions,0
" The following exceptions are the exceptions that are usually raised. The following exceptions are kept for compatibility with previous versions; starting from Python 3.3, they are aliases of OSError",Built-in Exceptions,0
" The following exceptions are kept for compatibility with previous versions; starting from Python 3.3, they are aliases of OSError. The following exceptions are used as warning categories; see the Warning Categories documentation for more details",Built-in Exceptions,0
"3, they are aliases of OSError. The following exceptions are used as warning categories; see the Warning Categories documentation for more details. The following are used when it is necessary to raise multiple unrelated exceptions",Built-in Exceptions,0
 The following exceptions are used as warning categories; see the Warning Categories documentation for more details. The following are used when it is necessary to raise multiple unrelated exceptions. They are part of the exception hierarchy so they can be handled with except like all other exceptions,Built-in Exceptions,0
" The following are used when it is necessary to raise multiple unrelated exceptions. They are part of the exception hierarchy so they can be handled with except like all other exceptions. In addition, they are recognised by except*, which matches their subgroups based on the types of the contained exceptions",Built-in Exceptions,0
" They are part of the exception hierarchy so they can be handled with except like all other exceptions. In addition, they are recognised by except*, which matches their subgroups based on the types of the contained exceptions. The class hierarchy for built-in exceptions is:",Built-in Exceptions,0
"The following sections describe the standard types that are built into the interpreter. The principal built-in types are numerics, sequences, mappings, classes, instances and exceptions. Some collection classes are mutable",Built-in Types,1
" The principal built-in types are numerics, sequences, mappings, classes, instances and exceptions. Some collection classes are mutable.  The methods that add, subtract, or rearrange their members in place, and don’t return a specific item, never return the collection instance itself but None",Built-in Types,1
" Some collection classes are mutable.  The methods that add, subtract, or rearrange their members in place, and don’t return a specific item, never return the collection instance itself but None. Some operations are supported by several object types; in particular, practically all objects can be compared for equality, tested for truth value, and converted to a string (with the repr() function or the slightly different str() function)",Built-in Types,1
"  The methods that add, subtract, or rearrange their members in place, and don’t return a specific item, never return the collection instance itself but None. Some operations are supported by several object types; in particular, practically all objects can be compared for equality, tested for truth value, and converted to a string (with the repr() function or the slightly different str() function).  The latter function is implicitly used when an object is written by the print() function",Built-in Types,1
" Some operations are supported by several object types; in particular, practically all objects can be compared for equality, tested for truth value, and converted to a string (with the repr() function or the slightly different str() function).  The latter function is implicitly used when an object is written by the print() function. Any object can be tested for truth value, for use in an if or while condition or as operand of the Boolean operations below",Built-in Types,1
"  The latter function is implicitly used when an object is written by the print() function. Any object can be tested for truth value, for use in an if or while condition or as operand of the Boolean operations below. By default, an object is considered true unless its class defines either a __bool__() method that returns False or a __len__() method that returns zero, when called with the object",Built-in Types,1
" Any object can be tested for truth value, for use in an if or while condition or as operand of the Boolean operations below. By default, an object is considered true unless its class defines either a __bool__() method that returns False or a __len__() method that returns zero, when called with the object. 1  Here are most of the built-in objects considered false: Operations and built-in functions that have a Boolean result always return 0 or False for false and 1 or True for true, unless otherwise stated",Built-in Types,1
" By default, an object is considered true unless its class defines either a __bool__() method that returns False or a __len__() method that returns zero, when called with the object. 1  Here are most of the built-in objects considered false: Operations and built-in functions that have a Boolean result always return 0 or False for false and 1 or True for true, unless otherwise stated. (Important exception: the Boolean operations or and and always return one of their operands",Built-in Types,1
" 1  Here are most of the built-in objects considered false: Operations and built-in functions that have a Boolean result always return 0 or False for false and 1 or True for true, unless otherwise stated. (Important exception: the Boolean operations or and and always return one of their operands.)",Built-in Types,1
" (Important exception: the Boolean operations or and and always return one of their operands.). These are the Boolean operations, ordered by ascending priority: Notes: This is a short-circuit operator, so it only evaluates the second argument if the first one is false",Built-in Types,1
"). These are the Boolean operations, ordered by ascending priority: Notes: This is a short-circuit operator, so it only evaluates the second argument if the first one is false. This is a short-circuit operator, so it only evaluates the second argument if the first one is true",Built-in Types,1
" These are the Boolean operations, ordered by ascending priority: Notes: This is a short-circuit operator, so it only evaluates the second argument if the first one is false. This is a short-circuit operator, so it only evaluates the second argument if the first one is true. not has a lower priority than non-Boolean operators, so not a == b is interpreted as not (a == b), and a == not b is a syntax error",Built-in Types,1
" This is a short-circuit operator, so it only evaluates the second argument if the first one is true. not has a lower priority than non-Boolean operators, so not a == b is interpreted as not (a == b), and a == not b is a syntax error. There are eight comparison operations in Python",Built-in Types,1
" not has a lower priority than non-Boolean operators, so not a == b is interpreted as not (a == b), and a == not b is a syntax error. There are eight comparison operations in Python.  They all have the same priority (which is higher than that of the Boolean operations)",Built-in Types,1
" There are eight comparison operations in Python.  They all have the same priority (which is higher than that of the Boolean operations).  Comparisons can be chained arbitrarily; for example, x < y <= z is equivalent to x < y and y <= z, except that y is evaluated only once (but in both cases z is not evaluated at all when x < y is found to be false)",Built-in Types,1
"  They all have the same priority (which is higher than that of the Boolean operations).  Comparisons can be chained arbitrarily; for example, x < y <= z is equivalent to x < y and y <= z, except that y is evaluated only once (but in both cases z is not evaluated at all when x < y is found to be false). This table summarizes the comparison operations: Objects of different types, except different numeric types, never compare equal",Built-in Types,1
"  Comparisons can be chained arbitrarily; for example, x < y <= z is equivalent to x < y and y <= z, except that y is evaluated only once (but in both cases z is not evaluated at all when x < y is found to be false). This table summarizes the comparison operations: Objects of different types, except different numeric types, never compare equal. The == operator is always defined but for some object types (for example, class objects) is equivalent to is",Built-in Types,1
" This table summarizes the comparison operations: Objects of different types, except different numeric types, never compare equal. The == operator is always defined but for some object types (for example, class objects) is equivalent to is. The <, <=, > and >= operators are only defined where they make sense; for example, they raise a TypeError exception when one of the arguments is a complex number",Built-in Types,1
" The == operator is always defined but for some object types (for example, class objects) is equivalent to is. The <, <=, > and >= operators are only defined where they make sense; for example, they raise a TypeError exception when one of the arguments is a complex number. Non-identical instances of a class normally compare as non-equal unless the class defines the __eq__() method",Built-in Types,1
" The <, <=, > and >= operators are only defined where they make sense; for example, they raise a TypeError exception when one of the arguments is a complex number. Non-identical instances of a class normally compare as non-equal unless the class defines the __eq__() method. Instances of a class cannot be ordered with respect to other instances of the same class, or other types of object, unless the class defines enough of the methods __lt__(), __le__(), __gt__(), and __ge__() (in general, __lt__() and __eq__() are sufficient, if you want the conventional meanings of the comparison operators)",Built-in Types,1
" Non-identical instances of a class normally compare as non-equal unless the class defines the __eq__() method. Instances of a class cannot be ordered with respect to other instances of the same class, or other types of object, unless the class defines enough of the methods __lt__(), __le__(), __gt__(), and __ge__() (in general, __lt__() and __eq__() are sufficient, if you want the conventional meanings of the comparison operators). The behavior of the is and is not operators cannot be customized; also they can be applied to any two objects and never raise an exception",Built-in Types,1
" Instances of a class cannot be ordered with respect to other instances of the same class, or other types of object, unless the class defines enough of the methods __lt__(), __le__(), __gt__(), and __ge__() (in general, __lt__() and __eq__() are sufficient, if you want the conventional meanings of the comparison operators). The behavior of the is and is not operators cannot be customized; also they can be applied to any two objects and never raise an exception. Two more operations with the same syntactic priority, in and not in, are supported by types that are iterable or implement the __contains__() method",Built-in Types,1
" The behavior of the is and is not operators cannot be customized; also they can be applied to any two objects and never raise an exception. Two more operations with the same syntactic priority, in and not in, are supported by types that are iterable or implement the __contains__() method. There are three distinct numeric types: integers, floating point numbers, and complex numbers",Built-in Types,1
" Two more operations with the same syntactic priority, in and not in, are supported by types that are iterable or implement the __contains__() method. There are three distinct numeric types: integers, floating point numbers, and complex numbers.  In addition, Booleans are a subtype of integers",Built-in Types,1
" There are three distinct numeric types: integers, floating point numbers, and complex numbers.  In addition, Booleans are a subtype of integers.  Integers have unlimited precision",Built-in Types,1
"  In addition, Booleans are a subtype of integers.  Integers have unlimited precision.  Floating point numbers are usually implemented using double in C; information about the precision and internal representation of floating point numbers for the machine on which your program is running is available in sys",Built-in Types,1
  Integers have unlimited precision.  Floating point numbers are usually implemented using double in C; information about the precision and internal representation of floating point numbers for the machine on which your program is running is available in sys.float_info,Built-in Types,1
"  Floating point numbers are usually implemented using double in C; information about the precision and internal representation of floating point numbers for the machine on which your program is running is available in sys.float_info.  Complex numbers have a real and imaginary part, which are each a floating point number",Built-in Types,1
"float_info.  Complex numbers have a real and imaginary part, which are each a floating point number.  To extract these parts from a complex number z, use z",Built-in Types,1
"  Complex numbers have a real and imaginary part, which are each a floating point number.  To extract these parts from a complex number z, use z.real and z",Built-in Types,1
"  To extract these parts from a complex number z, use z.real and z.imag",Built-in Types,1
real and z.imag. (The standard library includes the additional numeric types fractions,Built-in Types,1
"imag. (The standard library includes the additional numeric types fractions.Fraction, for rationals, and decimal",Built-in Types,1
" (The standard library includes the additional numeric types fractions.Fraction, for rationals, and decimal.Decimal, for floating-point numbers with user-definable precision",Built-in Types,1
"Fraction, for rationals, and decimal.Decimal, for floating-point numbers with user-definable precision.) Numbers are created by numeric literals or as the result of built-in functions and operators",Built-in Types,1
"Decimal, for floating-point numbers with user-definable precision.) Numbers are created by numeric literals or as the result of built-in functions and operators.  Unadorned integer literals (including hex, octal and binary numbers) yield integers",Built-in Types,1
") Numbers are created by numeric literals or as the result of built-in functions and operators.  Unadorned integer literals (including hex, octal and binary numbers) yield integers.  Numeric literals containing a decimal point or an exponent sign yield floating point numbers",Built-in Types,1
"  Unadorned integer literals (including hex, octal and binary numbers) yield integers.  Numeric literals containing a decimal point or an exponent sign yield floating point numbers.  Appending 'j' or 'J' to a numeric literal yields an imaginary number (a complex number with a zero real part) which you can add to an integer or float to get a complex number with real and imaginary parts",Built-in Types,1
"  Numeric literals containing a decimal point or an exponent sign yield floating point numbers.  Appending 'j' or 'J' to a numeric literal yields an imaginary number (a complex number with a zero real part) which you can add to an integer or float to get a complex number with real and imaginary parts. Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the “narrower” type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex",Built-in Types,1
"  Appending 'j' or 'J' to a numeric literal yields an imaginary number (a complex number with a zero real part) which you can add to an integer or float to get a complex number with real and imaginary parts. Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the “narrower” type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex. A comparison between numbers of different types behaves as though the exact values of those numbers were being compared",Built-in Types,1
" Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the “narrower” type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex. A comparison between numbers of different types behaves as though the exact values of those numbers were being compared. 2 The constructors int(), float(), and complex() can be used to produce numbers of a specific type",Built-in Types,1
" A comparison between numbers of different types behaves as though the exact values of those numbers were being compared. 2 The constructors int(), float(), and complex() can be used to produce numbers of a specific type. All numeric types (except complex) support the following operations (for priorities of the operations, see Operator precedence): Notes: All numbers",Built-in Types,1
" 2 The constructors int(), float(), and complex() can be used to produce numbers of a specific type. All numeric types (except complex) support the following operations (for priorities of the operations, see Operator precedence): Notes: All numbers.Real types (int and float) also include the following operations: For additional numeric operations see the math and cmath modules",Built-in Types,1
" All numeric types (except complex) support the following operations (for priorities of the operations, see Operator precedence): Notes: All numbers.Real types (int and float) also include the following operations: For additional numeric operations see the math and cmath modules. Also referred to as integer division",Built-in Types,1
"Real types (int and float) also include the following operations: For additional numeric operations see the math and cmath modules. Also referred to as integer division.  The resultant value is a whole integer, though the result’s type is not necessarily int",Built-in Types,1
" Also referred to as integer division.  The resultant value is a whole integer, though the result’s type is not necessarily int.  The result is always rounded towards minus infinity: 1//2 is 0, (-1)//2 is -1, 1//(-2) is -1, and (-1)//(-2) is 0",Built-in Types,1
"  The resultant value is a whole integer, though the result’s type is not necessarily int.  The result is always rounded towards minus infinity: 1//2 is 0, (-1)//2 is -1, 1//(-2) is -1, and (-1)//(-2) is 0. Not for complex numbers",Built-in Types,1
"  The result is always rounded towards minus infinity: 1//2 is 0, (-1)//2 is -1, 1//(-2) is -1, and (-1)//(-2) is 0. Not for complex numbers.  Instead convert to floats using abs() if appropriate",Built-in Types,1
 Not for complex numbers.  Instead convert to floats using abs() if appropriate. Conversion from floating point to integer may round or truncate as in C; see functions math,Built-in Types,1
  Instead convert to floats using abs() if appropriate. Conversion from floating point to integer may round or truncate as in C; see functions math.floor() and math,Built-in Types,1
 Conversion from floating point to integer may round or truncate as in C; see functions math.floor() and math.ceil() for well-defined conversions,Built-in Types,1
floor() and math.ceil() for well-defined conversions.  float also accepts the strings “nan” and “inf” with an optional prefix “+” or “-” for Not a Number (NaN) and positive or negative infinity,Built-in Types,1
"ceil() for well-defined conversions.  float also accepts the strings “nan” and “inf” with an optional prefix “+” or “-” for Not a Number (NaN) and positive or negative infinity. Python defines pow(0, 0) and 0 ** 0 to be 1, as is common for programming languages",Built-in Types,1
"  float also accepts the strings “nan” and “inf” with an optional prefix “+” or “-” for Not a Number (NaN) and positive or negative infinity. Python defines pow(0, 0) and 0 ** 0 to be 1, as is common for programming languages. The numeric literals accepted include the digits 0 to 9 or any Unicode equivalent (code points with the Nd property)",Built-in Types,1
" Python defines pow(0, 0) and 0 ** 0 to be 1, as is common for programming languages. The numeric literals accepted include the digits 0 to 9 or any Unicode equivalent (code points with the Nd property). See https://www",Built-in Types,1
 The numeric literals accepted include the digits 0 to 9 or any Unicode equivalent (code points with the Nd property). See https://www.unicode,Built-in Types,1
 See https://www.unicode.org/Public/14,Built-in Types,1
unicode.org/Public/14.0,Built-in Types,1
org/Public/14.0.0/ucd/extracted/DerivedNumericType,Built-in Types,1
0.0/ucd/extracted/DerivedNumericType.txt for a complete list of code points with the Nd property,Built-in Types,1
0/ucd/extracted/DerivedNumericType.txt for a complete list of code points with the Nd property. ,Built-in Types,1
txt for a complete list of code points with the Nd property. . Python supports a concept of iteration over containers,Built-in Types,1
 . Python supports a concept of iteration over containers.  This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration,Built-in Types,1
" Python supports a concept of iteration over containers.  This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration.  Sequences, described below in more detail, always support the iteration methods",Built-in Types,1
"  This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration.  Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iterable support: The iterator objects themselves are required to support the following two methods, which together form the iterator protocol: Python defines several iterator objects to support iteration over general and specific sequence types, dictionaries, and other more specialized forms",Built-in Types,1
"  Sequences, described below in more detail, always support the iteration methods. One method needs to be defined for container objects to provide iterable support: The iterator objects themselves are required to support the following two methods, which together form the iterator protocol: Python defines several iterator objects to support iteration over general and specific sequence types, dictionaries, and other more specialized forms.  The specific types are not important beyond their implementation of the iterator protocol",Built-in Types,1
" One method needs to be defined for container objects to provide iterable support: The iterator objects themselves are required to support the following two methods, which together form the iterator protocol: Python defines several iterator objects to support iteration over general and specific sequence types, dictionaries, and other more specialized forms.  The specific types are not important beyond their implementation of the iterator protocol. Once an iterator’s __next__() method raises StopIteration, it must continue to do so on subsequent calls",Built-in Types,1
"  The specific types are not important beyond their implementation of the iterator protocol. Once an iterator’s __next__() method raises StopIteration, it must continue to do so on subsequent calls. Implementations that do not obey this property are deemed broken",Built-in Types,1
" Once an iterator’s __next__() method raises StopIteration, it must continue to do so on subsequent calls. Implementations that do not obey this property are deemed broken. There are three basic sequence types: lists, tuples, and range objects",Built-in Types,1
" Implementations that do not obey this property are deemed broken. There are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of binary data and text strings are described in dedicated sections",Built-in Types,1
" There are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of binary data and text strings are described in dedicated sections. Textual data in Python is handled with str objects, or strings",Built-in Types,1
" Additional sequence types tailored for processing of binary data and text strings are described in dedicated sections. Textual data in Python is handled with str objects, or strings. Strings are immutable sequences of Unicode code points",Built-in Types,1
" Textual data in Python is handled with str objects, or strings. Strings are immutable sequences of Unicode code points.  String literals are written in a variety of ways: Triple quoted strings may span multiple lines - all associated whitespace will be included in the string literal",Built-in Types,1
 Strings are immutable sequences of Unicode code points.  String literals are written in a variety of ways: Triple quoted strings may span multiple lines - all associated whitespace will be included in the string literal. String literals that are part of a single expression and have only whitespace between them will be implicitly converted to a single string literal,Built-in Types,1
"  String literals are written in a variety of ways: Triple quoted strings may span multiple lines - all associated whitespace will be included in the string literal. String literals that are part of a single expression and have only whitespace between them will be implicitly converted to a single string literal. That is, (""spam "" ""eggs"") == ""spam eggs""",Built-in Types,1
" String literals that are part of a single expression and have only whitespace between them will be implicitly converted to a single string literal. That is, (""spam "" ""eggs"") == ""spam eggs"". See String and Bytes literals for more about the various forms of string literal, including supported escape sequences, and the r (“raw”) prefix that disables most escape sequence processing",Built-in Types,1
" That is, (""spam "" ""eggs"") == ""spam eggs"". See String and Bytes literals for more about the various forms of string literal, including supported escape sequences, and the r (“raw”) prefix that disables most escape sequence processing. Strings may also be created from other objects using the str constructor",Built-in Types,1
" See String and Bytes literals for more about the various forms of string literal, including supported escape sequences, and the r (“raw”) prefix that disables most escape sequence processing. Strings may also be created from other objects using the str constructor. Since there is no separate “character” type, indexing a string produces strings of length 1",Built-in Types,1
" Strings may also be created from other objects using the str constructor. Since there is no separate “character” type, indexing a string produces strings of length 1. That is, for a non-empty string s, s[0] == s[0:1]",Built-in Types,1
" Since there is no separate “character” type, indexing a string produces strings of length 1. That is, for a non-empty string s, s[0] == s[0:1]. There is also no mutable string type, but str",Built-in Types,1
" That is, for a non-empty string s, s[0] == s[0:1]. There is also no mutable string type, but str.join() or io",Built-in Types,1
" There is also no mutable string type, but str.join() or io.StringIO can be used to efficiently construct strings from multiple fragments",Built-in Types,1
join() or io.StringIO can be used to efficiently construct strings from multiple fragments. The core built-in types for manipulating binary data are bytes and bytearray,Built-in Types,1
StringIO can be used to efficiently construct strings from multiple fragments. The core built-in types for manipulating binary data are bytes and bytearray. They are supported by memoryview which uses the buffer protocol to access the memory of other binary objects without needing to make a copy,Built-in Types,1
 The core built-in types for manipulating binary data are bytes and bytearray. They are supported by memoryview which uses the buffer protocol to access the memory of other binary objects without needing to make a copy. The array module supports efficient storage of basic data types like 32-bit integers and IEEE754 double-precision floating values,Built-in Types,1
 They are supported by memoryview which uses the buffer protocol to access the memory of other binary objects without needing to make a copy. The array module supports efficient storage of basic data types like 32-bit integers and IEEE754 double-precision floating values. A set object is an unordered collection of distinct hashable objects,Built-in Types,1
" The array module supports efficient storage of basic data types like 32-bit integers and IEEE754 double-precision floating values. A set object is an unordered collection of distinct hashable objects. Common uses include membership testing, removing duplicates from a sequence, and computing mathematical operations such as intersection, union, difference, and symmetric difference",Built-in Types,1
" A set object is an unordered collection of distinct hashable objects. Common uses include membership testing, removing duplicates from a sequence, and computing mathematical operations such as intersection, union, difference, and symmetric difference. (For other containers see the built-in dict, list, and tuple classes, and the collections module",Built-in Types,1
" Common uses include membership testing, removing duplicates from a sequence, and computing mathematical operations such as intersection, union, difference, and symmetric difference. (For other containers see the built-in dict, list, and tuple classes, and the collections module.) Like other collections, sets support x in set, len(set), and for x in set",Built-in Types,1
" (For other containers see the built-in dict, list, and tuple classes, and the collections module.) Like other collections, sets support x in set, len(set), and for x in set.  Being an unordered collection, sets do not record element position or order of insertion",Built-in Types,1
") Like other collections, sets support x in set, len(set), and for x in set.  Being an unordered collection, sets do not record element position or order of insertion.  Accordingly, sets do not support indexing, slicing, or other sequence-like behavior",Built-in Types,1
"  Being an unordered collection, sets do not record element position or order of insertion.  Accordingly, sets do not support indexing, slicing, or other sequence-like behavior. There are currently two built-in set types, set and frozenset",Built-in Types,1
"  Accordingly, sets do not support indexing, slicing, or other sequence-like behavior. There are currently two built-in set types, set and frozenset. The set type is mutable — the contents can be changed using methods like add() and remove()",Built-in Types,1
" There are currently two built-in set types, set and frozenset. The set type is mutable — the contents can be changed using methods like add() and remove().  Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set",Built-in Types,1
" The set type is mutable — the contents can be changed using methods like add() and remove().  Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set.  The frozenset type is immutable and hashable — its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set",Built-in Types,1
"  Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set.  The frozenset type is immutable and hashable — its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set. Non-empty sets (not frozensets) can be created by placing a comma-separated list of elements within braces, for example: {'jack', 'sjoerd'}, in addition to the set constructor",Built-in Types,1
"  The frozenset type is immutable and hashable — its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set. Non-empty sets (not frozensets) can be created by placing a comma-separated list of elements within braces, for example: {'jack', 'sjoerd'}, in addition to the set constructor. The constructors for both classes work the same:",Built-in Types,1
" Non-empty sets (not frozensets) can be created by placing a comma-separated list of elements within braces, for example: {'jack', 'sjoerd'}, in addition to the set constructor. The constructors for both classes work the same:. A mapping object maps hashable values to arbitrary objects",Built-in Types,1
 The constructors for both classes work the same:. A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects,Built-in Types,1
" A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects.  There is currently only one standard mapping type, the dictionary",Built-in Types,1
" Mappings are mutable objects.  There is currently only one standard mapping type, the dictionary.  (For other containers see the built-in list, set, and tuple classes, and the collections module",Built-in Types,1
"  There is currently only one standard mapping type, the dictionary.  (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values",Built-in Types,1
"  (For other containers see the built-in list, set, and tuple classes, and the collections module.) A dictionary’s keys are almost arbitrary values.  Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys",Built-in Types,1
") A dictionary’s keys are almost arbitrary values.  Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Values that compare equal (such as 1, 1",Built-in Types,1
"  Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Values that compare equal (such as 1, 1.0, and True) can be used interchangeably to index the same dictionary entry",Built-in Types,1
" Values that compare equal (such as 1, 1.0, and True) can be used interchangeably to index the same dictionary entry. Python’s with statement supports the concept of a runtime context defined by a context manager",Built-in Types,1
"0, and True) can be used interchangeably to index the same dictionary entry. Python’s with statement supports the concept of a runtime context defined by a context manager.  This is implemented using a pair of methods that allow user-defined classes to define a runtime context that is entered before the statement body is executed and exited when the statement ends: Python defines several context managers to support easy thread synchronisation, prompt closure of files or other objects, and simpler manipulation of the active decimal arithmetic context",Built-in Types,1
" Python’s with statement supports the concept of a runtime context defined by a context manager.  This is implemented using a pair of methods that allow user-defined classes to define a runtime context that is entered before the statement body is executed and exited when the statement ends: Python defines several context managers to support easy thread synchronisation, prompt closure of files or other objects, and simpler manipulation of the active decimal arithmetic context. The specific types are not treated specially beyond their implementation of the context management protocol",Built-in Types,1
"  This is implemented using a pair of methods that allow user-defined classes to define a runtime context that is entered before the statement body is executed and exited when the statement ends: Python defines several context managers to support easy thread synchronisation, prompt closure of files or other objects, and simpler manipulation of the active decimal arithmetic context. The specific types are not treated specially beyond their implementation of the context management protocol. See the contextlib module for some examples",Built-in Types,1
 The specific types are not treated specially beyond their implementation of the context management protocol. See the contextlib module for some examples. Python’s generators and the contextlib,Built-in Types,1
 See the contextlib module for some examples. Python’s generators and the contextlib.contextmanager decorator provide a convenient way to implement these protocols,Built-in Types,1
 Python’s generators and the contextlib.contextmanager decorator provide a convenient way to implement these protocols.  If a generator function is decorated with the contextlib,Built-in Types,1
"contextmanager decorator provide a convenient way to implement these protocols.  If a generator function is decorated with the contextlib.contextmanager decorator, it will return a context manager implementing the necessary __enter__() and __exit__() methods, rather than the iterator produced by an undecorated generator function",Built-in Types,1
"  If a generator function is decorated with the contextlib.contextmanager decorator, it will return a context manager implementing the necessary __enter__() and __exit__() methods, rather than the iterator produced by an undecorated generator function. Note that there is no specific slot for any of these methods in the type structure for Python objects in the Python/C API",Built-in Types,1
"contextmanager decorator, it will return a context manager implementing the necessary __enter__() and __exit__() methods, rather than the iterator produced by an undecorated generator function. Note that there is no specific slot for any of these methods in the type structure for Python objects in the Python/C API. Extension types wanting to define these methods must provide them as a normal Python accessible method",Built-in Types,1
" Note that there is no specific slot for any of these methods in the type structure for Python objects in the Python/C API. Extension types wanting to define these methods must provide them as a normal Python accessible method. Compared to the overhead of setting up the runtime context, the overhead of a single class dictionary lookup is negligible",Built-in Types,1
" Extension types wanting to define these methods must provide them as a normal Python accessible method. Compared to the overhead of setting up the runtime context, the overhead of a single class dictionary lookup is negligible. The core built-in types for type annotations are Generic Alias and Union",Built-in Types,1
" Compared to the overhead of setting up the runtime context, the overhead of a single class dictionary lookup is negligible. The core built-in types for type annotations are Generic Alias and Union. The interpreter supports several other kinds of objects",Built-in Types,1
 The core built-in types for type annotations are Generic Alias and Union. The interpreter supports several other kinds of objects. Most of these support only one or two operations,Built-in Types,1
" The interpreter supports several other kinds of objects. Most of these support only one or two operations. The implementation adds a few special read-only attributes to several object types, where they are relevant",Built-in Types,1
" Most of these support only one or two operations. The implementation adds a few special read-only attributes to several object types, where they are relevant.  Some of these are not reported by the dir() built-in function",Built-in Types,1
" The implementation adds a few special read-only attributes to several object types, where they are relevant.  Some of these are not reported by the dir() built-in function. CPython has a global limit for converting between int and str to mitigate denial of service attacks",Built-in Types,1
  Some of these are not reported by the dir() built-in function. CPython has a global limit for converting between int and str to mitigate denial of service attacks. This limit only applies to decimal or other non-power-of-two number bases,Built-in Types,1
" CPython has a global limit for converting between int and str to mitigate denial of service attacks. This limit only applies to decimal or other non-power-of-two number bases. Hexadecimal, octal, and binary conversions are unlimited",Built-in Types,1
" This limit only applies to decimal or other non-power-of-two number bases. Hexadecimal, octal, and binary conversions are unlimited. The limit can be configured",Built-in Types,1
" Hexadecimal, octal, and binary conversions are unlimited. The limit can be configured. The int type in CPython is an abitrary length number stored in binary form (commonly known as a “bignum”)",Built-in Types,1
" The limit can be configured. The int type in CPython is an abitrary length number stored in binary form (commonly known as a “bignum”). There exists no algorithm that can convert a string to a binary integer or a binary integer to a string in linear time, unless the base is a power of 2",Built-in Types,1
" The int type in CPython is an abitrary length number stored in binary form (commonly known as a “bignum”). There exists no algorithm that can convert a string to a binary integer or a binary integer to a string in linear time, unless the base is a power of 2. Even the best known algorithms for base 10 have sub-quadratic complexity",Built-in Types,1
" There exists no algorithm that can convert a string to a binary integer or a binary integer to a string in linear time, unless the base is a power of 2. Even the best known algorithms for base 10 have sub-quadratic complexity. Converting a large value such as int('1' * 500_000) can take over a second on a fast CPU",Built-in Types,1
 Even the best known algorithms for base 10 have sub-quadratic complexity. Converting a large value such as int('1' * 500_000) can take over a second on a fast CPU. Limiting conversion size offers a practical way to avoid CVE-2020-10735,Built-in Types,1
 Converting a large value such as int('1' * 500_000) can take over a second on a fast CPU. Limiting conversion size offers a practical way to avoid CVE-2020-10735. The limit is applied to the number of digit characters in the input or output string when a non-linear conversion algorithm would be involved,Built-in Types,1
 Limiting conversion size offers a practical way to avoid CVE-2020-10735. The limit is applied to the number of digit characters in the input or output string when a non-linear conversion algorithm would be involved.  Underscores and the sign are not counted towards the limit,Built-in Types,1
" The limit is applied to the number of digit characters in the input or output string when a non-linear conversion algorithm would be involved.  Underscores and the sign are not counted towards the limit. When an operation would exceed the limit, a ValueError is raised: The default limit is 4300 digits as provided in sys",Built-in Types,1
"  Underscores and the sign are not counted towards the limit. When an operation would exceed the limit, a ValueError is raised: The default limit is 4300 digits as provided in sys.int_info",Built-in Types,1
" When an operation would exceed the limit, a ValueError is raised: The default limit is 4300 digits as provided in sys.int_info.default_max_str_digits",Built-in Types,1
int_info.default_max_str_digits. The lowest limit that can be configured is 640 digits as provided in sys,Built-in Types,1
default_max_str_digits. The lowest limit that can be configured is 640 digits as provided in sys.int_info,Built-in Types,1
 The lowest limit that can be configured is 640 digits as provided in sys.int_info.str_digits_check_threshold,Built-in Types,1
int_info.str_digits_check_threshold. Verification:,Built-in Types,1
 The built-in string class provides the ability to do complex variable substitutions and value formatting via the format() method described in PEP 3101.  The Formatter class in the string module allows you to create and customize your own string formatting behaviors using the same implementation as the built-in format() method. The str,String,2
"  The Formatter class in the string module allows you to create and customize your own string formatting behaviors using the same implementation as the built-in format() method. The str.format() method and the Formatter class share the same syntax for format strings (although in the case of Formatter, subclasses can define their own format string syntax)",String,2
" The str.format() method and the Formatter class share the same syntax for format strings (although in the case of Formatter, subclasses can define their own format string syntax).  The syntax is related to that of formatted string literals, but it is less sophisticated and, in particular, does not support arbitrary expressions",String,2
"format() method and the Formatter class share the same syntax for format strings (although in the case of Formatter, subclasses can define their own format string syntax).  The syntax is related to that of formatted string literals, but it is less sophisticated and, in particular, does not support arbitrary expressions. Format strings contain replacement fields surrounded by curly braces {}",String,2
"  The syntax is related to that of formatted string literals, but it is less sophisticated and, in particular, does not support arbitrary expressions. Format strings contain replacement fields surrounded by curly braces {}. Anything that is not contained in braces is considered literal text, which is copied unchanged to the output",String,2
" Format strings contain replacement fields surrounded by curly braces {}. Anything that is not contained in braces is considered literal text, which is copied unchanged to the output.  If you need to include a brace character in the literal text, it can be escaped by doubling: {{ and }}",String,2
" Anything that is not contained in braces is considered literal text, which is copied unchanged to the output.  If you need to include a brace character in the literal text, it can be escaped by doubling: {{ and }}. The grammar for a replacement field is as follows: In less formal terms, the replacement field can start with a field_name that specifies the object whose value is to be formatted and inserted into the output instead of the replacement field",String,2
"  If you need to include a brace character in the literal text, it can be escaped by doubling: {{ and }}. The grammar for a replacement field is as follows: In less formal terms, the replacement field can start with a field_name that specifies the object whose value is to be formatted and inserted into the output instead of the replacement field. The field_name is optionally followed by a  conversion field, which is preceded by an exclamation point '!', and a format_spec, which is preceded by a colon ':'",String,2
" The grammar for a replacement field is as follows: In less formal terms, the replacement field can start with a field_name that specifies the object whose value is to be formatted and inserted into the output instead of the replacement field. The field_name is optionally followed by a  conversion field, which is preceded by an exclamation point '!', and a format_spec, which is preceded by a colon ':'.  These specify a non-default format for the replacement value",String,2
" The field_name is optionally followed by a  conversion field, which is preceded by an exclamation point '!', and a format_spec, which is preceded by a colon ':'.  These specify a non-default format for the replacement value. See also the Format Specification Mini-Language section",String,2
  These specify a non-default format for the replacement value. See also the Format Specification Mini-Language section. The field_name itself begins with an arg_name that is either a number or a keyword,String,2
" See also the Format Specification Mini-Language section. The field_name itself begins with an arg_name that is either a number or a keyword.  If its a number, it refers to a positional argument, and if its a keyword, it refers to a named keyword argument",String,2
" The field_name itself begins with an arg_name that is either a number or a keyword.  If its a number, it refers to a positional argument, and if its a keyword, it refers to a named keyword argument.  If the numerical arg_names in a format string are 0, 1, 2, in sequence, they can all be omitted (not just some) and the numbers 0, 1, 2,  will be automatically inserted in that order",String,2
"  If its a number, it refers to a positional argument, and if its a keyword, it refers to a named keyword argument.  If the numerical arg_names in a format string are 0, 1, 2, in sequence, they can all be omitted (not just some) and the numbers 0, 1, 2,  will be automatically inserted in that order. Because arg_name is not quote-delimited, it is not possible to specify arbitrary dictionary keys (e",String,2
"  If the numerical arg_names in a format string are 0, 1, 2, in sequence, they can all be omitted (not just some) and the numbers 0, 1, 2,  will be automatically inserted in that order. Because arg_name is not quote-delimited, it is not possible to specify arbitrary dictionary keys (e.g",String,2
" Because arg_name is not quote-delimited, it is not possible to specify arbitrary dictionary keys (e.g., the strings '10' or ':-]') within a format string",String,2
"g., the strings '10' or ':-]') within a format string. The arg_name can be followed by any number of index or attribute expressions",String,2
", the strings '10' or ':-]') within a format string. The arg_name can be followed by any number of index or attribute expressions. An expression of the form '",String,2
" The arg_name can be followed by any number of index or attribute expressions. An expression of the form '.name' selects the named attribute using getattr(), while an expression of the form '[index]' does an index lookup using __getitem__()",String,2
" An expression of the form '.name' selects the named attribute using getattr(), while an expression of the form '[index]' does an index lookup using __getitem__(). Some simple format string examples: The conversion field causes a type coercion before formatting",String,2
"name' selects the named attribute using getattr(), while an expression of the form '[index]' does an index lookup using __getitem__(). Some simple format string examples: The conversion field causes a type coercion before formatting.  Normally, the job of formatting a value is done by the __format__() method of the value itself",String,2
" Some simple format string examples: The conversion field causes a type coercion before formatting.  Normally, the job of formatting a value is done by the __format__() method of the value itself.  However, in some cases it is desirable to force a type to be formatted as a string, overriding its own definition of formatting",String,2
"  Normally, the job of formatting a value is done by the __format__() method of the value itself.  However, in some cases it is desirable to force a type to be formatted as a string, overriding its own definition of formatting.  By converting the value to a string before calling __format__(), the normal formatting logic is bypassed",String,2
"  However, in some cases it is desirable to force a type to be formatted as a string, overriding its own definition of formatting.  By converting the value to a string before calling __format__(), the normal formatting logic is bypassed. Three conversion flags are currently supported: '!s' which calls str() on the value, '!r' which calls repr() and '!a' which calls ascii()",String,2
"  By converting the value to a string before calling __format__(), the normal formatting logic is bypassed. Three conversion flags are currently supported: '!s' which calls str() on the value, '!r' which calls repr() and '!a' which calls ascii(). Some examples: The format_spec field contains a specification of how the value should be presented, including such details as field width, alignment, padding, decimal precision and so on",String,2
" Three conversion flags are currently supported: '!s' which calls str() on the value, '!r' which calls repr() and '!a' which calls ascii(). Some examples: The format_spec field contains a specification of how the value should be presented, including such details as field width, alignment, padding, decimal precision and so on.  Each value type can define its own formatting mini-language or interpretation of the format_spec",String,2
" Some examples: The format_spec field contains a specification of how the value should be presented, including such details as field width, alignment, padding, decimal precision and so on.  Each value type can define its own formatting mini-language or interpretation of the format_spec. Most built-in types support a common formatting mini-language, which is described in the next section",String,2
"  Each value type can define its own formatting mini-language or interpretation of the format_spec. Most built-in types support a common formatting mini-language, which is described in the next section. A format_spec field can also include nested replacement fields within it",String,2
" Most built-in types support a common formatting mini-language, which is described in the next section. A format_spec field can also include nested replacement fields within it. These nested replacement fields may contain a field name, conversion flag and format specification, but deeper nesting is not allowed",String,2
" A format_spec field can also include nested replacement fields within it. These nested replacement fields may contain a field name, conversion flag and format specification, but deeper nesting is not allowed.  The replacement fields within the format_spec are substituted before the format_spec string is interpreted",String,2
" These nested replacement fields may contain a field name, conversion flag and format specification, but deeper nesting is not allowed.  The replacement fields within the format_spec are substituted before the format_spec string is interpreted. This allows the formatting of a value to be dynamically specified",String,2
  The replacement fields within the format_spec are substituted before the format_spec string is interpreted. This allows the formatting of a value to be dynamically specified. See the Format examples section for some examples,String,2
 This allows the formatting of a value to be dynamically specified. See the Format examples section for some examples. Template strings provide simpler string substitutions as described in PEP 292,String,2
" See the Format examples section for some examples. Template strings provide simpler string substitutions as described in PEP 292.  A primary use case for template strings is for internationalization (i18n) since in that context, the simpler syntax and functionality makes it easier to translate than other built-in string formatting facilities in Python",String,2
" Template strings provide simpler string substitutions as described in PEP 292.  A primary use case for template strings is for internationalization (i18n) since in that context, the simpler syntax and functionality makes it easier to translate than other built-in string formatting facilities in Python.  As an example of a library built on template strings for i18n, see the flufl",String,2
"  A primary use case for template strings is for internationalization (i18n) since in that context, the simpler syntax and functionality makes it easier to translate than other built-in string formatting facilities in Python.  As an example of a library built on template strings for i18n, see the flufl.i18n package",String,2
"  As an example of a library built on template strings for i18n, see the flufl.i18n package. Template strings support $-based substitutions, using the following rules: Any other appearance of $ in the string will result in a ValueError being raised",String,2
"i18n package. Template strings support $-based substitutions, using the following rules: Any other appearance of $ in the string will result in a ValueError being raised. The string module provides a Template class that implements these rules",String,2
" Template strings support $-based substitutions, using the following rules: Any other appearance of $ in the string will result in a ValueError being raised. The string module provides a Template class that implements these rules.  The methods of Template are: Here is an example of how to use a Template: Advanced usage: you can derive subclasses of Template to customize the placeholder syntax, delimiter character, or the entire regular expression used to parse template strings",String,2
" The string module provides a Template class that implements these rules.  The methods of Template are: Here is an example of how to use a Template: Advanced usage: you can derive subclasses of Template to customize the placeholder syntax, delimiter character, or the entire regular expression used to parse template strings.  To do this, you can override these class attributes: Alternatively, you can provide the entire regular expression pattern by overriding the class attribute pattern",String,2
"  The methods of Template are: Here is an example of how to use a Template: Advanced usage: you can derive subclasses of Template to customize the placeholder syntax, delimiter character, or the entire regular expression used to parse template strings.  To do this, you can override these class attributes: Alternatively, you can provide the entire regular expression pattern by overriding the class attribute pattern.  If you do this, the value must be a regular expression object with four named capturing groups",String,2
"  To do this, you can override these class attributes: Alternatively, you can provide the entire regular expression pattern by overriding the class attribute pattern.  If you do this, the value must be a regular expression object with four named capturing groups.  The capturing groups correspond to the rules given above, along with the invalid placeholder rule: The methods on this class will raise ValueError if the pattern matches the template without one of these named groups matching",String,2
"  If you do this, the value must be a regular expression object with four named capturing groups.  The capturing groups correspond to the rules given above, along with the invalid placeholder rule: The methods on this class will raise ValueError if the pattern matches the template without one of these named groups matching. Format specifications are used within replacement fields contained within a format string to define how individual values are presented (see Format String Syntax and Formatted string literals)",String,2
"  The capturing groups correspond to the rules given above, along with the invalid placeholder rule: The methods on this class will raise ValueError if the pattern matches the template without one of these named groups matching. Format specifications are used within replacement fields contained within a format string to define how individual values are presented (see Format String Syntax and Formatted string literals). They can also be passed directly to the built-in format() function",String,2
 Format specifications are used within replacement fields contained within a format string to define how individual values are presented (see Format String Syntax and Formatted string literals). They can also be passed directly to the built-in format() function.  Each formattable type may define how the format specification is to be interpreted,String,2
" They can also be passed directly to the built-in format() function.  Each formattable type may define how the format specification is to be interpreted. Most built-in types implement the following options for format specifications, although some of the formatting options are only supported by the numeric types",String,2
"  Each formattable type may define how the format specification is to be interpreted. Most built-in types implement the following options for format specifications, although some of the formatting options are only supported by the numeric types. A general convention is that an empty format specification produces the same result as if you had called str() on the value",String,2
" Most built-in types implement the following options for format specifications, although some of the formatting options are only supported by the numeric types. A general convention is that an empty format specification produces the same result as if you had called str() on the value. A non-empty format specification typically modifies the result",String,2
" A general convention is that an empty format specification produces the same result as if you had called str() on the value. A non-empty format specification typically modifies the result. The general form of a standard format specifier is: If a valid align value is specified, it can be preceded by a fill character that can be any character and defaults to a space if omitted",String,2
" A non-empty format specification typically modifies the result. The general form of a standard format specifier is: If a valid align value is specified, it can be preceded by a fill character that can be any character and defaults to a space if omitted. It is not possible to use a literal curly brace ({ or }) as the fill character in a formatted string literal or when using the str",String,2
" The general form of a standard format specifier is: If a valid align value is specified, it can be preceded by a fill character that can be any character and defaults to a space if omitted. It is not possible to use a literal curly brace ({ or }) as the fill character in a formatted string literal or when using the str.format() method",String,2
" It is not possible to use a literal curly brace ({ or }) as the fill character in a formatted string literal or when using the str.format() method.  However, it is possible to insert a curly brace with a nested replacement field",String,2
"format() method.  However, it is possible to insert a curly brace with a nested replacement field.  This limitation doesnt affect the format() function",String,2
"  However, it is possible to insert a curly brace with a nested replacement field.  This limitation doesnt affect the format() function. The meaning of the various alignment options is as follows: Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case",String,2
"  This limitation doesnt affect the format() function. The meaning of the various alignment options is as follows: Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case. The sign option is only valid for number types, and can be one of the following: The 'z' option coerces negative zero floating-point values to positive zero after rounding to the format precision",String,2
" The meaning of the various alignment options is as follows: Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case. The sign option is only valid for number types, and can be one of the following: The 'z' option coerces negative zero floating-point values to positive zero after rounding to the format precision.  This option is only valid for floating-point presentation types",String,2
" The sign option is only valid for number types, and can be one of the following: The 'z' option coerces negative zero floating-point values to positive zero after rounding to the format precision.  This option is only valid for floating-point presentation types. The '#' option causes the alternate form to be used for the conversion",String,2
  This option is only valid for floating-point presentation types. The '#' option causes the alternate form to be used for the conversion.  The alternate form is defined differently for different types,String,2
" The '#' option causes the alternate form to be used for the conversion.  The alternate form is defined differently for different types.  This option is only valid for integer, float and complex types",String,2
"  The alternate form is defined differently for different types.  This option is only valid for integer, float and complex types. For integers, when binary, octal, or hexadecimal output is used, this option adds the respective prefix '0b', '0o', '0x', or '0X' to the output value",String,2
"  This option is only valid for integer, float and complex types. For integers, when binary, octal, or hexadecimal output is used, this option adds the respective prefix '0b', '0o', '0x', or '0X' to the output value. For float and complex the alternate form causes the result of the conversion to always contain a decimal-point character, even if no digits follow it",String,2
" For integers, when binary, octal, or hexadecimal output is used, this option adds the respective prefix '0b', '0o', '0x', or '0X' to the output value. For float and complex the alternate form causes the result of the conversion to always contain a decimal-point character, even if no digits follow it. Normally, a decimal-point character appears in the result of these conversions only if a digit follows it",String,2
" For float and complex the alternate form causes the result of the conversion to always contain a decimal-point character, even if no digits follow it. Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. In addition, for 'g' and 'G' conversions, trailing zeros are not removed from the result",String,2
" Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. In addition, for 'g' and 'G' conversions, trailing zeros are not removed from the result. The ',' option signals the use of a comma for a thousands separator",String,2
" In addition, for 'g' and 'G' conversions, trailing zeros are not removed from the result. The ',' option signals the use of a comma for a thousands separator. For a locale aware separator, use the 'n' integer presentation type instead",String,2
" The ',' option signals the use of a comma for a thousands separator. For a locale aware separator, use the 'n' integer presentation type instead. The '_' option signals the use of an underscore for a thousands separator for floating point presentation types and for integer presentation type 'd'",String,2
" For a locale aware separator, use the 'n' integer presentation type instead. The '_' option signals the use of an underscore for a thousands separator for floating point presentation types and for integer presentation type 'd'.  For integer presentation types 'b', 'o', 'x', and 'X', underscores will be inserted every 4 digits",String,2
" The '_' option signals the use of an underscore for a thousands separator for floating point presentation types and for integer presentation type 'd'.  For integer presentation types 'b', 'o', 'x', and 'X', underscores will be inserted every 4 digits.  For other presentation types, specifying this option is an error",String,2
"  For integer presentation types 'b', 'o', 'x', and 'X', underscores will be inserted every 4 digits.  For other presentation types, specifying this option is an error. width is a decimal integer defining the minimum total field width, including any prefixes, separators, and other formatting characters",String,2
"  For other presentation types, specifying this option is an error. width is a decimal integer defining the minimum total field width, including any prefixes, separators, and other formatting characters. If not specified, then the field width will be determined by the content",String,2
" width is a decimal integer defining the minimum total field width, including any prefixes, separators, and other formatting characters. If not specified, then the field width will be determined by the content. When no explicit alignment is given, preceding the width field by a zero ('0') character enables sign-aware zero-padding for numeric types",String,2
" If not specified, then the field width will be determined by the content. When no explicit alignment is given, preceding the width field by a zero ('0') character enables sign-aware zero-padding for numeric types.  This is equivalent to a fill character of '0' with an alignment type of '='",String,2
" When no explicit alignment is given, preceding the width field by a zero ('0') character enables sign-aware zero-padding for numeric types.  This is equivalent to a fill character of '0' with an alignment type of '='. The precision is a decimal integer indicating how many digits should be displayed after the decimal point for presentation types 'f' and 'F', or before and after the decimal point for presentation types 'g' or 'G'",String,2
"  This is equivalent to a fill character of '0' with an alignment type of '='. The precision is a decimal integer indicating how many digits should be displayed after the decimal point for presentation types 'f' and 'F', or before and after the decimal point for presentation types 'g' or 'G'.  For string presentation types the field indicates the maximum field size - in other words, how many characters will be used from the field content",String,2
" The precision is a decimal integer indicating how many digits should be displayed after the decimal point for presentation types 'f' and 'F', or before and after the decimal point for presentation types 'g' or 'G'.  For string presentation types the field indicates the maximum field size - in other words, how many characters will be used from the field content.  The precision is not allowed for integer presentation types",String,2
"  For string presentation types the field indicates the maximum field size - in other words, how many characters will be used from the field content.  The precision is not allowed for integer presentation types. Finally, the type determines how the data should be presented",String,2
"  The precision is not allowed for integer presentation types. Finally, the type determines how the data should be presented. The available string presentation types are: The available integer presentation types are: In addition to the above presentation types, integers can be formatted with the floating point presentation types listed below (except 'n' and None)",String,2
" Finally, the type determines how the data should be presented. The available string presentation types are: The available integer presentation types are: In addition to the above presentation types, integers can be formatted with the floating point presentation types listed below (except 'n' and None). When doing so, float() is used to convert the integer to a floating point number before formatting",String,2
" The available string presentation types are: The available integer presentation types are: In addition to the above presentation types, integers can be formatted with the floating point presentation types listed below (except 'n' and None). When doing so, float() is used to convert the integer to a floating point number before formatting. The available presentation types for float and Decimal values are: This section contains examples of the str",String,2
" When doing so, float() is used to convert the integer to a floating point number before formatting. The available presentation types for float and Decimal values are: This section contains examples of the str.format() syntax and comparison with the old %-formatting",String,2
" The available presentation types for float and Decimal values are: This section contains examples of the str.format() syntax and comparison with the old %-formatting. In most of the cases the syntax is similar to the old %-formatting, with the addition of the {} and with : used instead of %",String,2
"format() syntax and comparison with the old %-formatting. In most of the cases the syntax is similar to the old %-formatting, with the addition of the {} and with : used instead of %. For example, '%03",String,2
" In most of the cases the syntax is similar to the old %-formatting, with the addition of the {} and with : used instead of %. For example, '%03.2f' can be translated to '{:03",String,2
" For example, '%03.2f' can be translated to '{:03.2f}'",String,2
"2f' can be translated to '{:03.2f}'. The new format syntax also supports new and different options, shown in the following examples",String,2
"2f}'. The new format syntax also supports new and different options, shown in the following examples. Accessing arguments by position: Accessing arguments by name: Accessing arguments attributes: Accessing arguments items: Replacing %s and %r: Aligning the text and specifying a width: Replacing %+f, %-f, and % f and specifying a sign: Replacing %x and %o and converting the value to different bases: Using the comma as a thousands separator: Expressing a percentage: Using type-specific formatting: Nesting arguments and more complex examples:",String,2
" A regular expression (or RE) specifies a set of strings that matches it; the functions in this module let you check if a particular string matches a given regular expression (or if a given regular expression matches a particular string, which comes down to the same thing). Regular expressions can be concatenated to form new regular expressions; if A and B are both regular expressions, then AB is also a regular expression. In general, if a string p matches A and another string q matches B, the string pq will match AB",regex,3
" Regular expressions can be concatenated to form new regular expressions; if A and B are both regular expressions, then AB is also a regular expression. In general, if a string p matches A and another string q matches B, the string pq will match AB.  This holds unless A or B contain low precedence operations; boundary conditions between A and B; or have numbered group references",regex,3
" In general, if a string p matches A and another string q matches B, the string pq will match AB.  This holds unless A or B contain low precedence operations; boundary conditions between A and B; or have numbered group references.  Thus, complex expressions can easily be constructed from simpler primitive expressions like the ones described here",regex,3
"  This holds unless A or B contain low precedence operations; boundary conditions between A and B; or have numbered group references.  Thus, complex expressions can easily be constructed from simpler primitive expressions like the ones described here.  For details of the theory and implementation of regular expressions, consult the Friedl book [Frie09], or almost any textbook about compiler construction",regex,3
"  Thus, complex expressions can easily be constructed from simpler primitive expressions like the ones described here.  For details of the theory and implementation of regular expressions, consult the Friedl book [Frie09], or almost any textbook about compiler construction. A brief explanation of the format of regular expressions follows",regex,3
"  For details of the theory and implementation of regular expressions, consult the Friedl book [Frie09], or almost any textbook about compiler construction. A brief explanation of the format of regular expressions follows.  For further information and a gentler presentation, consult the Regular Expression HOWTO",regex,3
" A brief explanation of the format of regular expressions follows.  For further information and a gentler presentation, consult the Regular Expression HOWTO. Regular expressions can contain both special and ordinary characters",regex,3
"  For further information and a gentler presentation, consult the Regular Expression HOWTO. Regular expressions can contain both special and ordinary characters. Most ordinary characters, like 'A', 'a', or '0', are the simplest regular expressions; they simply match themselves",regex,3
" Regular expressions can contain both special and ordinary characters. Most ordinary characters, like 'A', 'a', or '0', are the simplest regular expressions; they simply match themselves.  You can concatenate ordinary characters, so last matches the string 'last'",regex,3
" Most ordinary characters, like 'A', 'a', or '0', are the simplest regular expressions; they simply match themselves.  You can concatenate ordinary characters, so last matches the string 'last'.  (In the rest of this section, well write REs in this special style, usually without quotes, and strings to be matched 'in single quotes'",regex,3
"  You can concatenate ordinary characters, so last matches the string 'last'.  (In the rest of this section, well write REs in this special style, usually without quotes, and strings to be matched 'in single quotes'.) Some characters, like '|' or '(', are special",regex,3
"  (In the rest of this section, well write REs in this special style, usually without quotes, and strings to be matched 'in single quotes'.) Some characters, like '|' or '(', are special. Special characters either stand for classes of ordinary characters, or affect how the regular expressions around them are interpreted",regex,3
") Some characters, like '|' or '(', are special. Special characters either stand for classes of ordinary characters, or affect how the regular expressions around them are interpreted. Repetition operators or quantifiers (*, +, ?, {m,n}, etc) cannot be directly nested",regex,3
" Special characters either stand for classes of ordinary characters, or affect how the regular expressions around them are interpreted. Repetition operators or quantifiers (*, +, ?, {m,n}, etc) cannot be directly nested. This avoids ambiguity with the non-greedy modifier suffix ?, and with other modifiers in other implementations",regex,3
" Repetition operators or quantifiers (*, +, ?, {m,n}, etc) cannot be directly nested. This avoids ambiguity with the non-greedy modifier suffix ?, and with other modifiers in other implementations. To apply a second repetition to an inner repetition, parentheses may be used",regex,3
" This avoids ambiguity with the non-greedy modifier suffix ?, and with other modifiers in other implementations. To apply a second repetition to an inner repetition, parentheses may be used. For example, the expression (?:a{6})* matches any multiple of six 'a' characters",regex,3
" To apply a second repetition to an inner repetition, parentheses may be used. For example, the expression (?:a{6})* matches any multiple of six 'a' characters. The special characters are: The special sequences consist of '\' and a character from the list below",regex,3
" For example, the expression (?:a{6})* matches any multiple of six 'a' characters. The special characters are: The special sequences consist of '\' and a character from the list below. If the ordinary character is not an ASCII digit or an ASCII letter, then the resulting RE will match the second character",regex,3
" The special characters are: The special sequences consist of '\' and a character from the list below. If the ordinary character is not an ASCII digit or an ASCII letter, then the resulting RE will match the second character.  For example, \$ matches the character '$'",regex,3
" If the ordinary character is not an ASCII digit or an ASCII letter, then the resulting RE will match the second character.  For example, \$ matches the character '$'. Most of the standard escapes supported by Python string literals are also accepted by the regular expression parser: (Note that \b is used to represent word boundaries, and means backspace only inside character classes",regex,3
"  For example, \$ matches the character '$'. Most of the standard escapes supported by Python string literals are also accepted by the regular expression parser: (Note that \b is used to represent word boundaries, and means backspace only inside character classes.) ' ', '\U', and '\N' escape sequences are only recognized in Unicode patterns",regex,3
" Most of the standard escapes supported by Python string literals are also accepted by the regular expression parser: (Note that \b is used to represent word boundaries, and means backspace only inside character classes.) ' ', '\U', and '\N' escape sequences are only recognized in Unicode patterns.  In bytes patterns they are errors",regex,3
") ' ', '\U', and '\N' escape sequences are only recognized in Unicode patterns.  In bytes patterns they are errors.  Unknown escapes of ASCII letters are reserved for future use and treated as errors",regex,3
  In bytes patterns they are errors.  Unknown escapes of ASCII letters are reserved for future use and treated as errors. Octal escapes are included in a limited form,regex,3
"  Unknown escapes of ASCII letters are reserved for future use and treated as errors. Octal escapes are included in a limited form.  If the first digit is a 0, or if there are three octal digits, it is considered an octal escape",regex,3
" Octal escapes are included in a limited form.  If the first digit is a 0, or if there are three octal digits, it is considered an octal escape. Otherwise, it is a group reference",regex,3
"  If the first digit is a 0, or if there are three octal digits, it is considered an octal escape. Otherwise, it is a group reference.  As for string literals, octal escapes are always at most three digits in length",regex,3
" Otherwise, it is a group reference.  As for string literals, octal escapes are always at most three digits in length. The module defines several functions, constants, and an exception",regex,3
"  As for string literals, octal escapes are always at most three digits in length. The module defines several functions, constants, and an exception. Some of the functions are simplified versions of the full featured methods for compiled regular expressions",regex,3
" The module defines several functions, constants, and an exception. Some of the functions are simplified versions of the full featured methods for compiled regular expressions.  Most non-trivial applications always use the compiled form",regex,3
 Some of the functions are simplified versions of the full featured methods for compiled regular expressions.  Most non-trivial applications always use the compiled form. Compiled regular expression objects support the following methods and attributes: Match objects always have a boolean value of True,regex,3
"  Most non-trivial applications always use the compiled form. Compiled regular expression objects support the following methods and attributes: Match objects always have a boolean value of True. Since match() and search() return None when there is no match, you can test whether there was a match with a simple if statement: Match objects support the following methods and attributes:",regex,3
How to fix the Telethon's exception BadMessageError I'm doing an application to download all files form a Telegram channel. When downloading I receive the error message:     Anyone know how to fix this? ,built-in-exceptions,0
"Why does handling multiple exceptions require a tuple, but not a list? Consider the following example:    The tuple is the correct way to handle multiple exception types. Using a list for the multiple exception types causes neither to be handled.  I am wondering why Python syntax requires a tuple for multiple exception types.  The docs say that it uses a tuple, so perhaps it is just ""never was implemented using a list instead of a tuple.""  It seems reasonable to me that a list could also be used in this situation, conceptually at least.  Is there any reason why Python uses a tuple instead of a list for this situation? ",built-in-exceptions,0
"Catch specific errors in python I was trying to catch a specific exception:    But instead of going into the if loop, I am getting:    Why is this happening? How can I catch a specific exception? ",built-in-exceptions,0
"Are errnos contained by python's exceptions the same with the errnos in ""linux/errno.h""? As far as I know, most of the errnos returned by python's exceptions are the same with the errnos in ""linux/errno.h"". But at sometimes, things are not like what I expect:  For example, when a socket connection throw a socket.timeout exception, the errno it returned should be 110, however, it's errno is always :    Secondly, when a address-related exception is throwed, the errno will be negative, but the errnos in linux/errno.h are between 1 and 133:    In this case, will print -5.  I'm so confused of all of these errnos. :( ",built-in-exceptions,0
"xlsxwriter module won't open/close Excel file correctly I'm writing a program that writes data to an Excel file using the  module.  The code that opens the workbook is:    This used to work. Then I changed some stuff around in the bottom of the program (waaaaay after that line) and now it doesn't work, saying this:    This has happened when I forget to close the file before running it again (as it is trying to write to a file that's open in Excel which won't work), but I don't even have Excel open and it does this.  How can I fix this? Do I need to restart or something?  Also, I tried to have a  loop to stop the program if the initialization doesn't work. Even with  only, without a specific exception, it still completes the program unless I kill it manually. The script basically opens the Excel file, spends a long time downloading data from the Internet, and then writing that to the Excel file. I want it to stop if the initialization doesn't work so I don't have to wait for the script to complete (it can take up to 15 minutes). I'm pretty sure that it has something to do with the fact that it says """", but I'm not familiar with all the error-fu in Python.  EDIT:  I added an  command right at the end and now it doesn't give me the first error, but a second (and much larger and scarier) one:    EDIT 2:  The part of the code that actually writes to the file is this:    If I replace all the fancy  stuff with a single    it doesn't give me the error, and seems to work fine.  This doesn't provide the functionality I need, as some columns need to be formulas whose numbers change based on the row. What in the above code is causing the  line to bug out? ",built-in-exceptions,0
"what is the correct way to handle a caught exception and raise it outside of try block Im just starting my python learning journey and need some help with the correct way to raise an exception.   Consider a block of code which loops thru a list and performs a task. If an exception occurs,continue with the program execution. And execute the rest of the code. At the end of the program raise the exception and system the application with non zero code. The idea is the program should continue executing all the tasks, but exit with a non 0 code for an external application to track and report.    ",built-in-exceptions,0
"Django: save other object before raising exception I'm trying to do a simple error reporting system within my Django classes, but I cannot get to save a new object (from another class) if I raise a ValidationError.  Here is an example of what I want to do:    The problem is that if I raise an exception, even if it is risen after I do the h.save(), h doesn't get saved.  This makes all the sense because Django is so intelligent that shouldn't let you commit to the database if there is an error, but I can't find anywhere in the documentation where I can override this to deal with this specific situation.  ... or maybe I'm simply conceptually wrong and I have to deal with this elsewhere (I'm trying to do a robust system where others can write code for it so it should be fail-safe). ",built-in-exceptions,0
"Try and except both executed when called by another function There's something weird happening with my code, I have a first function that goes like this :    So this function works perfectly when called in the main program, but when I try to call function1 in another function2, both try#2 and except#2 are executed ! Cause directory1 is created and error message 1 is printed, also my info variable equals None.  How can calling function1 in a second function mess try and except clauses ?  Thank you ! ",built-in-exceptions,0
"python: How to check that returned value is exception or not I have two functions. function ""main"" is calling to function ""submain"". ""submain"" function contains try-catch block and return some value.  If ""submain"" executes successfully then it returns some value which i will display to end user directly.   If i get an exception then i have to prepare one user friendly message and print that. But to do that i need to know whether returned value is exception or not.   How can i check that returned value in exception or valid result?   ",built-in-exceptions,0
"Twisted and writing exceptions to stderr I am trying to use Twisted and Python together. I need to export exceptions and errors to a file rather than the console incase anything unexpected pops up during runtime and I happen to miss it, however redirecting stderr doesn't seem to work. The error still shows up in the console and it doesn't write to the file (although the file is created). Here is a minimal example:  What am I doing wrong? ",built-in-exceptions,0
"What is the difference between isinstance('aaa', basestring) and isinstance('aaa', str)?  ",built-in-types,1
Inheriting behaviours for set and frozenset seem to differ Can someone explain the following behaviour:    This is surprising to me that you can alter the constructor of a frozen set whereas it is not possible for the constructor of a mutable set. ,built-in-types,1
"use type() information to cast values stored as strings In my application I have generated a number of values (three columns, of type int, str and datetime, see example below) and these values are stored in a flat file as comma-separated strings. Furthermore, I store a file containing the type of the values (see below). Now, how can I use this information to cast my values from the flat file to the correct data type in Python? Is is possible or do I need to do some other stuff?  Data file:    Type file:      ",built-in-types,1
"How are built-in types protected from overwriting (assigning to) their methods? I noted that    yields an error.  I can see, why that is forbidden. But how? Can I use that in ""normal"" code? ",built-in-types,1
"subclassing float to force fixed point printing precision in python [Python 3.1]  I'm following up on this answer:    I know I need to keep track of my float literals (i.e., replace  with  , etc.), and that's fine.  But whenever I do any calculations,  objects get converted into .  What's the easiest way to fix it?  EDIT:  I need exactly two decimal digits; and I need it across the whole code, including where I print a dictionary with  values inside. That makes any formatting functions hard to use.  I can't use  global setting, since I want computations to be at full precision (just printing at 2 decimal points).  @Glenn Maynard: I agree I shouldn't override ; if anything, it would be just . But it's a moot point because of the following point.  @Glenn Maynard and @singularity: I won't subclass , since I agree it will look very ugly in the end.  I will stop trying to be clever, and just call a function everywhere a  is being printed. Though I am really sad that I can't override  in the builtin class .  Thank you! ",built-in-types,1
"Python built-in types subclassing What's wrong with this code?    When I create an instance of  with, for example, , and then I print this instance, all I get is an empty list . If  is subclassing , isn't  a  itself?  NB: both in Python 2.x and 3.x. ",built-in-types,1
"Redefining Pythons builtin datatypes Is it possible to redefine which object the brackets [] use?  I can subclass the  object, but how to I make the interpreter use my subclass in place of the buildin list object? Is it possible?   (I'm pretty sure I'm using the wrong terms for the question- feel free to edit)    I don't have a practical use for this- just curious.  ",built-in-types,1
How to display Django BooleanFields selected true in template? I created a model object. This object has several boolean fields.    Some of them are right and others are wrong.  I want to show only the fields that have the correct value in the template.  How can I do this in a shorter way instead of checking each field individually?   ,built-in-types,1
"Why are Python built-in type names not reserved keywords? In other words, why does Python allow variable names which are identical to built-in type names such as int, float, list, etc? (C++ built-in type names are all reserved, in comparison). Consider the example    The output is ""Is int"". However, if I uncomment the first line, the output will be ""Not int"". Obviously my ""int"" has overridden the built-in type int. That is, in my opinion, potentially dangerous. ",built-in-types,1
"Range() function not working I am trying to write the program that will be given a 2d list with coordinates of points on a grid (ex.), and will return all points passed during ""walking"". We can go diagonal.    We are using the example list as an input.   The problem is that the output is wrong and I do not know why:    And the output should be:    I think it is a problem of range function ",built-in-types,1
"If Input Equals Strings Do (Something) Not Working Python 3 I've recently been creating a text adventure game but almost immediately ran into a problem with the input. It is giving me error messages when I use strings instead of integers. There is probably an obvious reason that this is happening and I'm just not seeing it.  Here's an example:    I've researched a lot and this seems to be working for most other people. But when I use it I get this error:    As you can see, it says that y is not defined. I'm okay with basic python programming, but I'm horrible at reading error messages. It would be great if you guys could give me an answer. Thank you! ",string,2
How to convert numpy array elements from string to int I have a list of numbers in string format. I converted that list into numpy array using . How do I convert the string elements to ints? ,string,2
"Scraping paginated web table with python pandas & beautifulSoup I am a beginner in python pandas, i am trying to scrap a paginated table using beautiful soup package, the data is scraped, but the content of each cell comes in a single row, i couldn't get a coherent csv file  here is my code :     can anyone help me fix it please ",string,2
long <-> str binary conversion Is there any lib that convert very long numbers to string just copying the data?  These one-liners are too slow:   ,string,2
Replacing Strings using Loops in Python I'm still new to Python and I've had a hard time on how to Loop this.    The problem here is that I'm gonna add many .replace() functions if I'm given more than that.  Thank you so much for your help guys! ,string,2
Multiple specification in python string format I want to specify a certain width for my string and also specify the number of digit.  I can each of these formatting separately:    I could compound like this:    But how can I do both elegantly in 1 go? ,string,2
"Python Tracer Array I have the following problem: I want to Trace only outgoing packets and I have no idea how to sort them out. I want to save them to text file as well, ""on the fly"" or after I break compiling. Can anyone help? This is my code:   ",string,2
"How to convert multiple lines of strings into a text file I wrote a code that will calculate the mover distance between two text files. The code and the output is below:   What I want to do is to convert the output into a text file, which can store the results. I want the output text file to look something like below:  I am wondering are there anyways for me to achieve that? Thank you! ",string,2
how to split a string in a for loop I have a list of strings that look like:    and so on  I want to turn the list into just the last word of the sentence. my attempt so far has been:    when I run this I get     whereas when I do it individually for each string it works    How can I do this in a for loop? ,string,2
"How can I extract only subject:result from this string So I wrote a code to grab my exam results when it's released on the website. But I can't figure out how to output results in a subjectName:subjectResults format.  My output is something like this,      Results found b'{""examination"":""G.C.E. (O/L)   EXAMINATION"",""year"":""2018"",""name"":""NANAYAKKARA IGALA ARACHCHIGE   NAVINDU THARUKA   PERERA"",""indexNo"":""80299920"",""nic"":null,""districtRank"":null,""islandRank"":null,""marks"":null,""status"":null,""zScore"":null,""stream"":null,""subjectResults"":[{""subjectName"":""BUDDHISM"",""subjectResult"":""A""},{""subjectName"":""SINHALA   LANGUAGE &amp; LITT."",""subjectResult"":""A""},{""subjectName"":""ENGLISH   LANGUAGE"",""subjectResult"":""A""},{""subjectName"":""MATHEMATICS"",""subjectResult"":""A""},{""subjectName"":""HISTORY"",""subjectResult"":""A""},{""subjectName"":""SCIENCE"",""subjectResult"":""B""},{""subjectName"":""DRAMA   &amp; THEATRE(SINHALA)"",""subjectResult"":""A""},{""subjectName"":""BUSINESS &amp;   ACCT. STUDIES"",""subjectResult"":""A""},{""subjectName"":""INFOR. &amp; COMM.   TECHNOLOGY"",""subjectResult"":""A""}],""studentInfo"":[{""param"":""Examination"",""value"":""G.C.E.   (O/L)   EXAMINATION""},{""param"":""Year"",""value"":""2018""},{""param"":""Name"",""value"":""NANAYAKKARA   IGALA ARACHCHIGE NAVINDU THARUKA PERERA""},{""param"":""Index   Number"",""value"":""80299920""},{""param"":""NIC Number"",""value"":""""}]}'   I need just the subjects and their results listed line by line.  Here's my script   ",string,2
"Python extract quantifiable text (numbers) Hello I want to use python and extract text that is either a numeric value or a number spelled out plus the first word before and after the found value.  Example text:     I have 2 brothers and they bought one car each. My oldest   brother invested 1,000 dollars.   Expected Output:     I have tried this >    however this only worked for finding a value not the spelled out term . I also do not know what to use to get the word before and after the found word. ",regex,3
"List of pairs, find those who are not I read a list of pairs in the filesystem (Linux)... UniqueDocument.xml UniqueDocument.pdf  I need to find the entries that does not have a xml file, then I need to fetch it.  Been trying with os.list and regex but havent found a sutible solution and Dir() in Ruby. But I cant get to the end... my mind blocks me. ",regex,3
"Fetch string matching a pattern I have a text like this -     I want to fetch the document-id which is present in the above string as     The Id has a specific pattern -     The above string has other similar ids, but I am interested in getting the pattern after the substring  . Again this string is not fixed any kind of number, string or white space can come between  &amp;  ",regex,3
"How to replace part of an array based on another part of the array? my question is how do I scan ""my_list"" for ""comp"" and change the associated time value from 200 to ""t"" only if 200 is less than t?    Output:    The opposite could be done with this scenario as the list shouldn't change as ""t"" is less than ""5000"":    ",regex,3
"How to replace all instances of ""\/"" with ""/"" in a string? So I have a weird link like:     What I want to do is replace every  with just a .  When I try    It doesn't change anything. Any help is appreciated, thank you. ",regex,3
"Regex find a digit I have the following string,  and I need to parse ""2"" out of it. Here is what I'm trying:    How would I get ""Season 2"" here? ",regex,3
"How to look for phone numbers in a string of text Here is what I have so far:    I am guessing my regular expression for finding the phone number isnt great because if I take out the square brackets when printing call, it seems to give me the whole number and then it breaks down each set of numbers.  How could I polish this code ",regex,3
Regular expression for dataframe column I would like to take out only the date part of my dataframe column which has data like    I tried patterns like    but I am not able to exactly pick just the date part. ,regex,3
How to parse CSV data that contains newlines in field using pyspark The source data looks like below. One of the field from 4th record has multiline string.    I am reading this file through     Output of :    Output of     The issue here is the  data is treated as a new record. Due to which the count is also increased. How can I treat that  data as one string value of the column(which is starting with ) ? ,regex,3
"Python regular expression regex that will find double consonants within a word I need a regex in python that will return and double characters within a word if they are consonants. I tried , however it will also grab  in the word . For example, I want to return  from the word  but not  from  ",regex,3
